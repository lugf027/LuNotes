com: U2FsdGVkX1+U+A2mI7KX+EOi4r/qn/VlUtStuclBtN2xYt6/aLSurZ0tb440kCdJ

```
C / C++

* ++a 与 a++ 左值
* const
* 指向整型数组的指针 
* 指针与引用
* 指针++ 引用++
* C与C++区别
* C++ 对象在 main() 前分配内存 ?
* C++ 内存上的三种对象
* C++ static
* 继承 
* 封装 
* 多态
* 重载 重写 覆盖

数据结构/算法

* 快速排序
* 冒泡排序
* 平衡树
* 红黑树
* B+树
* B-树

数据库

* SQL语句拼接与注入
* 数据库 SELECT 语句 AST 设计
* BTree

计网/操作系统

* Http、Https
* Http/Https 挥手
* 进程线程区别
* 线程死锁
* 线程死锁解决方式
* 进程通信方式

其他

* Lex / Yacc
* 编译器 正则表达式 与 Token 流分析优缺点
* 数据库 SELECT 语句 AST 设计
* 缓存区溢出
```



### C++ static

```
c/c++的内存分布，以及static所在的区间，对于一个完整的程序，在内存中的分布情况如下图：　 
1.栈区：由编译器自动分配释放，像局部变量，函数参数，都是在栈区。会随着作用于退出而释放空间。
3.堆区：程序员分配并释放的区域，像malloc(c),new(c++) 
3.全局数据区(静态区)：全局变量和静态便令的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束释放。
4.代码区

C 语言的 static 关键字有三种（具体来说是两种）用途：

1. 静态局部变量：用于函数体内部修饰变量，这种变量的生存期长于该函数。
   导致：在第一次调用进入note:1的时候初始化（当初面试被坑过，我居然说是一开始就初始化了，汗！！）。且只初始化一次，也就是你第二次调用foo(),不会继续初始化，而会直接跳过。
   2.静态全局变量：定义在函数体外，用于修饰全局变量，表示该变量只在本文件可见。
   导致：文件隔离
   3.静态函数： 准确的说，静态函数跟静态全局变量的作用类似：
   导致：a.静态函数不能被其它文件所用;
      b.其它文件中可以定义相同名字的函数，不会发生冲突;

C++ 语言的 static 关键字有二种用途：
1.静态数据成员：用于修饰 class 的数据成员，即所谓“静态成员”。这种数据成员的生存期大于 class 的对象（实体 instance）。静态数据成员是每个 class 有一份，普通数据成员是每个 instance 有一份，因此静态数据成员也叫做类变量，而普通数据成员也叫做实例变量。
对于非静态数据成员，每个类对象(实例)都有自己的拷贝。而静态数据成员被当作是类的成员，由该类型的所有对象共享访问,对该类的多个对象来说，静态数据成员只分配一次内存。
静态数据成员存储在全局数据区。静态数据成员定义时要分配空间，所以不能在类声明中定义。

2、静态成员函数：用于修饰 class 的成员函数。
a.静态成员之间可以相互访问，包括静态成员函数访问静态数据成员和访问静态成员函数;
b.非静态成员函数可以任意地访问静态成员函数和静态数据成员;
c.静态成员函数不能访问非静态成员函数和非静态数据成员;
d.调用静态成员函数，可以用成员访问操作符(.)和(->)为一个类的对象或指向类对象的指针调用静态成员函数,也可以用类名::函数名调用(因为他本来就是属于类的，用类名调用很正常)
```



### C++三种对象

```
C++将内存划分为三个逻辑区域：堆、栈和静态存储区。既然如此，我称位于它们之中的对象分别为堆对象，栈对象以及静态对象。
栈对象的优势是在适当的时候自动生成，又在适当的时候自动销毁，不需要程序员操心；而且栈对象的创建速度一般较堆对象快，因为分配堆对象时，会调用operator new操作，operator new会采用某种内存空间搜索算法，而该搜索过程可能是很费时间的，产生栈对象则没有这么麻烦，它仅仅需要移动栈顶指针就可以了。但是要注意的是，通常栈空间容量比较小，一般是1MB～2MB，所以体积比较大的对象不适合在栈中分配。特别要注意递归函数中最好不要使用栈对象，因为随着递归调用深度的增加，所需的栈空间也会线性增加，当所需栈空间不够时，便会导致栈溢出，这样就会产生运行时错误。

　　堆对象，其产生时刻和销毁时刻都要程序员精确定义，也就是说，程序员对堆对象的生命具有完全的控制权。我们常常需要这样的对象，比如，我们需要创建一个对象，能够被多个函数所访问，但是又不想使其成为全局的，那么这个时候创建一个堆对象无疑是良好的选择，然后在各个函数之间传递这个堆对象的指针，便可以实现对该对象的共享。另外，相比于栈空间，堆的容量要大得多。实际上，当物理内存不够时，如果这时还需要生成新的堆对象，通常不会产生运行时错误，而是系统会使用虚拟内存来扩展实际的物理内存。 
接下来看看static对象。

　　首先是全局对象。全局对象为类间通信和函数间通信提供了一种最简单的方式，虽然这种方式并不优雅。一般而言，在完全的面向对象语言中，是不存在全局对象的，比如C#，因为全局对象意味着不安全和高耦合，在程序中过多地使用全局对象将大大降低程序的健壮性、稳定性、可维护性和可复用性。C++也完全可以剔除全局对象，但是最终没有，我想原因之一是为了兼容C。

　　其次是类的静态成员，上面已经提到，基类及其派生类的所有对象都共享这个静态成员对象，所以当需要在这些class之间或这些class objects之间进行数据共享或通信时，这样的静态成员无疑是很好的选择。

　　接着是静态局部对象，主要可用于保存该对象所在函数被屡次调用期间的中间状态，其中一个最显著的例子就是递归函数，我们都知道递归函数是自己调用自己的函数，如果在递归函数中定义一个nonstatic局部对象，那么当递归次数相当大时，所产生的开销也是巨大的。这是因为nonstatic局部对象是栈对象，每递归调用一次，就会产生一个这样的对象，每返回一次，就会释放这个对象，而且，这样的对象只局限于当前调用层，对于更深入的嵌套层和更浅露的外层，都是不可见的。每个层都有自己的局部对象和参数。

　　在递归函数设计中，可以使用static对象替代nonstatic局部对象（即栈对象），这不仅可以减少每次递归调用和返回时产生和释放nonstatic对象的开销，而且static对象还可以保存递归调用的中间状态，并且可为各个调用层所访问。 
```



#### C++ 对象在 main() 前分配内存 ?



#### 进程通信方式

```
一、管道
管道，通常指无名管道，是 UNIX 系统IPC最古老的形式。

1、特点：
它是半双工的（即数据只能在一个方向上流动），具有固定的读端和写端。

它只能用于具有亲缘关系的进程之间的通信（也是父子进程或者兄弟进程之间）。

它可以看成是一种特殊的文件，对于它的读写也可以使用普通的read、write 等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中。

二、FIFO
FIFO，也称为命名管道，它是一种文件类型。

1、特点
FIFO可以在无关的进程之间交换数据，与无名管道不同。

FIFO有路径名与之相关联，它以一种特殊设备文件形式存在于文件系统中。

三、消息队列
消息队列，是消息的链接表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标识。

1、特点
消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级。

消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除。

消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取。

四、信号量
信号量（semaphore）与已经介绍过的 IPC 结构不同，它是一个计数器。信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。

1、特点
信号量用于进程间同步，若要在进程间传递数据需要结合共享内存。

信号量基于操作系统的 PV 操作，程序对信号量的操作都是原子操作。

每次对信号量的 PV 操作不仅限于对信号量值加 1 或减 1，而且可以加减任意正整数。

支持信号量组。

五、共享内存
共享内存（Shared Memory），指两个或多个进程共享一个给定的存储区。

1、特点
共享内存是最快的一种 IPC，因为进程是直接对内存进行存取。

因为多个进程可以同时操作，所以需要进行同步。

信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问。
```



#### 线程死锁

```
1. 线程死锁的原因
   （1）互斥条件：一个资源每次只能被一个线程使用。
   （2）请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
   （3）不剥夺条件：进程已获得的资源，在未使用完之前，不能强行剥夺。
   （4）循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。

2. 死锁的解决办法
   如果发生了死锁，那么只要破坏死锁 4 个必要条件之一中的任何一个，死锁问题就能被解决。下面就是对于上面这些必要条件所作出的推想

（1）如果想要打破互斥条件，我们需要允许进程同时访问某些资源，这种方法受制于实际场景，不太容易实现条件；
（2）打破不可抢占条件，这样需要允许进程强行从占有者那里夺取某些资源，或者简单一点理解，占有资源的进程不能再申请占有其他资源，必须释放手上的资源之后才能发起申请，这个其实也很难找到适用场景；
（3）进程在运行前申请得到所有的资源，否则该进程不能进入准备执行状态。这个方法看似有点用处，但是它的缺点是可能导致资源利用率和进程并发性降低；
（4）避免出现资源申请环路，即对资源事先分类编号，按号分配。这种方式可以有效提高资源的利用率和系统吞吐量，但是增加了系统开销，增大了进程对资源的占用时间。

如果我们在死锁检查时发现了死锁情况，那么就要努力消除死锁，使系统从死锁状态中恢复过来。消除死锁的几种方式：
（1）最简单、最常用的方法就是进行系统的重新启动，不过这种方法代价很大，它意味着在这之前所有的进程已经完成的计算工作都将付之东流，包括参与死锁的那些进程，以及未参与死锁的进程；
（2）撤消进程，剥夺资源。终止参与死锁的进程，收回它们占有的资源，从而解除死锁。这时又分两种情况：一次性撤消参与死锁的全部进程，剥夺全部资源；或者逐步撤消参与死锁的进程，逐步收回死锁进程占有的资源。一般来说，选择逐步撤消的进程时要按照一定的原则进行，目的是撤消那些代价最小的进程，比如按进程的优先级确定进程的代价；考虑进程运行时的代价和与此进程相关的外部作业的代价等因素；
（3）进程回退策略，即让参与死锁的进程回退到没有发生死锁前某一点处，并由此点处继续执行，以求再次执行时不再发生死锁。虽然这是个较理想的办法，但是操作起来系统开销极大，要有堆栈这样的机构记录进程的每一步变化，以便今后的回退，有时这是无法做到的。
```





#### Http、Https



#### 内排序



#### 外排序



#### 编译器 正则表达式 与 Token 流分析优缺点



#### SQL注入

```
SQL注入即是指web应用程序对用户输入数据的合法性没有判断或过滤不严，攻击者可以在web应用程序中事先定义好的查询语句的结尾上添加额外的SQL语句，在管理员不知情的情况下实现非法操作，以此来实现欺骗数据库服务器执行非授权的任意查询，从而进一步得到相应的数据信息。


```



#### MyBatis 拼接 SQL 语句 （防注入？）



####  缓存区溢出

```
缓冲区溢出原理
缓冲区是一块连续的计算机内存区域，可保存相同数据类型的多个实例。缓冲区可以是堆栈(自动变量)、堆(动态内存)和静态数据区(全局或静态)。在C/C++语言中，通常使用字符数组和malloc/new之类内存分配函数实现缓冲区。溢出指数据被添加到分配给该缓冲区的内存块之外。缓冲区溢出是最常见的程序缺陷。

栈帧结构的引入为高级语言中实现函数或过程调用提供直接的硬件支持，但由于将函数返回地址这样的重要数据保存在程序员可见的堆栈中，因此也给系统安全带来隐患。若将函数返回地址修改为指向一段精心安排的恶意代码，则可达到危害系统安全的目的。此外，堆栈的正确恢复依赖于压栈的EBP值的正确性，但EBP域邻近局部变量，若编程中有意无意地通过局部变量的地址偏移窜改EBP值，则程序的行为将变得非常危险。

由于C/C++语言没有数组越界检查机制，当向局部数组缓冲区里写入的数据超过为其分配的大小时，就会发生缓冲区溢出。攻击者可利用缓冲区溢出来窜改进程运行时栈，从而改变程序正常流向，轻则导致程序崩溃，重则系统特权被窃取。

若攻击者用一个有意义的地址(否则会出现段错误)覆盖返回地址的内容，函数返回时就会去执行该地址处事先安排好的攻击代码。最常见的手段是通过制造缓冲区溢出使程序运行一个用户shell，再通过shell执行其它命令。若该程序有root或suid执行权限，则攻击者就获得一个有root权限的shell，进而可对系统进行任意操作。

除通过使堆栈缓冲区溢出而更改返回地址外，还可改写局部变量(尤其函数指针)以利用缓冲区溢出缺陷。

注意，本文描述的堆栈缓冲区溢出不同于广义的“堆栈溢出(Stack OverFlow)”，后者除局部数组越界和内存覆盖外，还可能由于调用层次太多(尤其应注意递归函数)或过大的局部变量所导致。
```



#### 红黑树





#### B+树 B-树



#### 重载 重写 覆盖

```markdown
**重载**

重载从overload翻译过来，是指同一可访问区内被声明的**几个具有不同参数列表（参数的类型，个数，顺序不同）的同名函数，根据参数列表确定调用哪个函数，重载不关心函数返回类型。**

1. 相同的范围（在同一个作用域中）
2. 函数名字相同
3. 参数不同列表
4. virtual 关键字可有可无
5. 返回类型可以不同

**重写**

　　重写翻译自override，是指**派生类中**存在重新定义的函数。其**函数名，参数列表，返回值类型，所有都必须同基类中被重写的函数一致**。只有函数体不同（花括号内），派生类调用时会调用派生类的重写函数，不会调用被重写函数。**重写的基类中被重写的函数必须有virtual修饰。**

1. 不在同一个作用域（分别位于派生类与基类）
2. 函数名字相同
3. 参数相同列表（参数个数，两个参数列表对应的类型）
4. 基类函数必须有 virtual 关键字，不能有 static，大概是多态的原因吧...
5. 返回值类型（或是协变），否则报错
6. 重写函数的访问修饰符可以不同。尽管 virtual 是 private 的，派生类中重写改写为 public,protected 也是可以的

**隐藏**

　　隐藏是指**派生类的函数屏蔽了与其同名的基类函数**。注意只要同名函数，不管参数列表是否相同，基类函数都会被隐藏。

1. 不在同一个作用域（分别位于派生类与基类）

2. 函数名字相同

3. 返回类型可以不同

4. 参数不同，此时，不论有无virtual关键字，基类的函数将被隐藏（注意别与重载混淆）而不是被重写

5. 参数相同，但是基类函数有无virtual关键字都会被隐藏。此时，基类的函数被隐藏（注意别与覆盖混淆）

   

**重载和重写的区别**

1. 范围区别：重写和被重写的函数在不同的类中，重载和被重载的函数在同一类中。
2. 参数区别：重写与被重写的函数参数列表一定相同，重载和被重载的函数参数列表一定不同。
3. virtual的区别：重写的基类必须要有virtual修饰，重载函数和被重载函数可以被virtual修饰，也可以没有。

**隐藏和重写，重载的区别**

1. 与重载范围不同：隐藏函数和被隐藏函数在不同类中。
2. 参数的区别：隐藏函数和被隐藏函数参数列表可以相同，也可以不同，但函数名一定同；当参数不同时，无论基类中的函数是否被virtual修饰，基类函数都是被隐藏，而不是被重写。


```



#### 继承 封装 多态



#### 指针++ 引用++



#### ++a  与 a++ 左值



#### const



#### 指向整型数组的指针 

```
int(*ptr)[]
```









