# C Traps and Pitfalls （《C缺陷与陷阱》）

1. '='与'==' 并 涉及到优先级时

   ```c
   while (c = ' ' || c == '\t' || c == '\n')
       c = getc(f);
   ```

   自己误分析为先将空格' '赋值给c，在while一直循环时，c值为空格的ASCII值32，实际是1.

   ```c
   while (c = (' ' || c == '\t' || c == '\n'));
   // 亦即
   while (c = ( 1 ));
   ```



2. lex 的贪心

   分析下段代码：

   ```c
   y = x/*p    /* p指向除数 */;
   ```

   从颜色也可以看出来，x后的/*p被编译器理解为一段注释的开始了。实际效果为 y=x;

   改写：

   ```c
   y = x / *p    /* p指向除数 */;
   // 原理：符号的中间不能嵌有空白，包括空格符、制表符、换行符。
   ```

   

   另注：老版本c语言允许使用 =+ 表示 += 的含义。比如

   ```c
   a=-1;
   
   // 亦即：
   
   a = a-1;
   
   // 但是通俗理解原意为：
   
   a = -1;
   ```

3. 练习1-1. 某些C编译器允许嵌套注释。请写-一个测试程序，要求:无论是
   对允许嵌套注释的编译器，还是对不允许嵌套注释的编译器，该程序都能正常通
   过编译(无错误消息出现)，但是这两种情况下程序执行的结果却不相同。
   (提示:在用双引号括起来的字符串中，注释符/* 属于字符串的一部分，而
   在注释中出现的双引号" "又属于注释的一部分。)

```
为了判断编译器是否允许嵌套注释，必须找到这样一组符号序列， 无论是对
于允许嵌套注释的编译器，还是不允许嵌套注释的编译器，它都是合法的;但是,
对于两类不同的编译器，它却意味着不同的事物。这样一组符号序列不可避免地
要涉及嵌套注释，让我们从这里开始讨论:

/*/**/

对于一个允许嵌套注释的C编译器，无论上面的符号序列后面跟什么，都属
于注释的一部分;而对于不允许嵌套注释的C编译器，后面跟的就是实实在在的
代码内容。也许有人因此想到可以在后面再跟一个用--对引号引起的注释结束符:

/*/**/"*/"
    
如果允许嵌套注释，上面的符号序列就等效于-一个引号;如果不允许，那么
就等效于一个字符串"*/"。因此，我们可以接着在后面跟一个注释开始符以及一
个引号:
    
/*/**/"*/"/**

如果允许嵌套注释，上面 就等效于用一对引号引起的注释开始符"/*";如果
不允许，那么就等效于一个用引号括起的注释结束符，后跟一段未结束的注释。
我们可以简单地让最后的注释结束:

/*/**/"*/"/*"/**/
    
这样，如果允许嵌套注释，. 上面的表达式就等效于"*/";如果不允许，那么就等效于"/*".
在我用基本上类似于上面的形式解决这个问题之后，Doug Mclroy发现了下
面这个让人拍案叫绝的解法:
    
/*/*/0*/**/1
    
这个解法主要利用了编译器作词法分析时的“大嘴法”规则。如果编译器允
许嵌套注释，则上式将被解释为:
    
/*/*/0*/**/ 1
两个/*符号与两个*/符号正好匹配，所以上式的值就是1。如果不允许嵌套注
释，注释中的/*将被忽略。因此，即使是/出现在注释中也没有特殊的含义;上面
的表达式因此将被这样解释:
    
/*/*/ 0* /**/ 1
    
它的值就是0*1，也就是0。

```


