# Questions of Interviews

Contents:

* [面经](#面经)

* [设计模式](#设计模式)
* [内部排序](#内部排序)
* [外部排序](#外部排序)
* [查找表结构](#查找表结构)

------



#### 面经

2020-10-20 from: 

U2FsdGVkX1+U+A2mI7KX+EOi4r/qn/VlUtStuclBtN2xYt6/aLSurZ0tb440kCdJ21W

```
C / C++
* ++a 与 a++ 左值
* const
* 指向整型数组的指针 
* 指针与引用
* 指针++ 引用++
* C与C++区别
* C++ 对象在 main() 前分配内存 ?
* C++ 内存上的三种对象
* C++ static
* 继承 
* 封装 
* 多态
* 重载 重写 覆盖

数据结构/算法
* 数组&链表索引对比 v
* 年龄排序/求最长寿N个人年龄总和 v
* 快速排序
* 冒泡排序
* 平衡树
* 红黑树
* B+树
* B-树

数据库
* SQL语句拼接与注入
* 数据库 SELECT 语句 AST 设计
* BTree

计网/操作系统
* Http、Https
* Http/Https 挥手
* https 一定安全吗
* 进程线程区别 v
* 线程死锁
* 线程死锁解决方式
* 进程通信方式

其他
* Lex / Yacc
* 编译器 正则表达式 与 Token 流分析优缺点
* 数据库 SELECT 语句 AST 设计
* 缓存区溢出
* 散列、解决Hash冲突
* 池
```

20201028 from:

U2FsdGVkX1/Nd51m0nBbhbK8Tu5xZYDN19fVcWFxY3M=

```
* const
* static 
* 四种 cast
* 四个智能指针
* HashTable 如何实现
* HashTable 如何解决碰撞冲突
* 虚函数与多态
* 多态
* extern C
* new malloc 区别
* 静态库、动态库 区别
* 栈溢出的情况，如何解决（递归过深怎么办）
* C++11 的新特性
* shared unique 应用场景
* 智能指针死锁与解决方法
* 智能指针使用的场景
* 宏定义
* 堆栈对象
* 指针、引用区别
* 指针、引用传参 区别与应用场景
* struct int char占几个字节 8个 能不能只占五个
* 内联函数 inline


* 判断两个单链表是否相交

* Linux 编译执行的整个过程
* 源代码到可执行程序的过程
* 分析 C++ 的函数调用过程

* 大端、小端
* 地址空间

* 进程、线程区别与应用场景
* 进程间的通信
* 进程的同步
* 管道通信的底层实现
* Linux fork 对进程间切换的优化
* 什么是协程
* 多线程并发控制
* 线程安全问题，如何保证线程安全
* 有没有写过多线程异步的代码
* 有哪几种锁
* 分页与分段机制
* 共享内存的原理与实现
* 存储区存什么数据
* 用户态 和 内核态

* 七层模型
* TCP UDP 为什么 UDP 没有建立连接
* TCP UDP 区别
* TCP中 TIME_WAIT 状态的作用
* TCP 四次挥手的原因
* 端口与传输层概念
* 拥塞状态 SYN FIN ACK
* 输入 url 到浏览页面经历了什么 用到了什么协议
* HTTP、HTTPS区别
* HTTP 短连接 长连接
* MD5
* DNS 劫持
* IP 攻击

* 数据库如何实现索引
* 数据库索引的底层数据结构
* 哈希表、B+树 区别与应用场景
* 红黑树、平衡树 区别与应用场景
* 为什么 unordered_map 用红黑树，数据库索引用B+树，二者区别
* 数据库引擎myisam innodb的区别与应用场景
* 索引 视图这些是用来做什么的 底层实现是什么
* 数据库内连接 外连接 左连接 右连接
* SQL语言的安全性 好像是插入SQL语言删数据库
* 数据库事务的概念 除了一致性

* 一台计算机从接通电源到进入操作系统 经历了什么 越详细越好
* 一个十四亿人口的数据库表 怎么优化 提高他的查询速率 怎么样保证高并发

* 写代码：字符串解码的左右可能性
* 写代码：字符串的反转
* 写代码：长度为n的无序int数组，其内容为1~n。找出其中重复的数字
* 写代码： ip白名单解析。ip白名单以英文逗号分割，每一项是一个ip或ip范围。给定一个ip白名单和要校验的ip，判断这个ip是否在ip白名单允许的范围内，若允许则返回true，否则返回false。
//例如ip白名单为192.148.1.2,192.168.3.0/24，ip为192.148.1.3返回false，ip为192.168.3.xxx则返回true。

* 智力题 一百本书 两个人来回取 每次取1-5本书 怎么保证你取到最后一本书
* 智力题  n本书 两个人来回取 每次取m本书 能否保证你取到最后一本书
```



from:

U2FsdGVkX1+xXI9c3P//f8FKFMBpVVKxYr6VPMGv7U8=

```
* tcp udp 的区别与应用场景
* udp 如何实现可靠传输
* c 语言与 C++ 语言的区别
* c 语言的 struct 如何实现 private 封装
* 虚函数有什么作用，属于面向对象的哪一个特性
```



from:

U2FsdGVkX19DONRdzTVCpdAiYZjH1YvVpHi4tYrwbus=

```
* 看过C++内存相关的书没
* C++ STL 源码相关的书
* 各个结构在内存中的存储方式

* 说一下操作系统内存
* 什么是中断

* MySQL index 索引

* 字符串不含重复字母的最长字串
```



20201027 from:

U2FsdGVkX19LIMlayydp+O9cPzS+7UMbArKdGWcHHgA=

```
* 写 实现 strcpy()
* 写 递归与循环分别实现二分查找
* 写 连连看核心功能，四种不同块，比较两个位置块是否可以消除
```



20201029 form:

U2FsdGVkX1+eXdY8uZOt2QnqT5/+DpudylNK0+C29iI=

```
* 面向对象、面向过程 区别与优缺点
* 面向过程是否可被面向对象永久替代了
* 智能指针
* const 
* static
* 快速排序
* TCP 三次握手细节问题
* 子类能够删除基类中的元素
* llvm PASS 如何处理 JSON / XML
* 指针、引用区别

* 数据库索引
* 数据库组件
* 描述知道的数据库语法

* 写代码： 如何判断单链表是否闭环
```



#### 设计模式：

    1软件设计模式概述
    2GoF 的 23 种设计模式
    3UML中的类图及类图之间的关系
    
    4开闭原则
    5里氏替换原则
    6依赖倒置原则
    7单一职责原则
    8接口隔离原则
    9迪米特法则
    10合成复用原则
    
    11创建型模式的特点和分类
    12单例模式
    13原型模式
    14简单工厂模式
    15工厂方法模式
    16抽象工厂模式
    17建造者模式
    
    18结构型模式概述
    19代理模式
    20适配器模式
    21桥接模式
    22装饰模式
    23外观模式
    24享元模式
    25组合模式
    
    26行为型模式概述
    27模板方法模式
    28策略模式
    29命令模式
    30责任链模式
    31状态模式
    32观察者模式
    33中介者模式
    34迭代器模式
    35访问者模式
    36备忘录模式
    37解释器模式
    
    38UMLet的使用与类图的设计
#### 内部排序

```
1. 插入排序算法及C语言实现
2. 折半插入排序算法（C语言代码实现）
3. 2路插入排序算法详解
4. 表插入排序算法
5. 希尔排序算法（缩小增量排序）及C语言实现
6. 冒泡排序（起泡排序）算法及其C语言实现
7. 快速排序（QSort，快排）算法及C语言实现
8. 简单选择排序算法（C语言详解版）
9. 树形选择排序（锦标赛排序）算法详解
10. 堆排序算法C语言详解
11. 归并排序算法（包含C语言实现代码）
12. 基数排序算法详解（C语言代码实现）
13. 内部排序算法的优势分析
```

#### 外部排序

```
1. 什么是外部排序算法
2. 多路平衡归并排序（胜者树、败者树）算法详解
3. 置换选择排序算法详解
4. 最佳归并树详解
```

#### 查找表结构

```
1. 什么是查找表
2. 顺序查找算法详解（包含C语言实现代码） v
3. 二分查找（折半查找）算法详解（C语言实现） v
4. 分块查找（索引顺序查找）算法及C语言实现 v
5. 静态树表查找算法详解
6. 二叉排序树（二叉查找树）及C语言实现
7. 平衡二叉树（AVL树）及C语言实现
8. 红黑树（更高级的二叉查找树）算法详解
9. B-树及其基本操作（插入和删除）详解
10. B+树及基本操作（插入和删除）详解
11. 键树查找法（双链树和字典树）及C语言实现
12. 哈希表（散列表）详解（包含哈希表处理冲突的方法）
13. 哈希查找算法（C语言实现）
```



大小端

大端模式，是指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中，这样的存储模式有点儿类似于把数据当作字符串顺序处理：地址由小向大增加，而数据从高位往低位放；这和我们的阅读习惯一致。
小端模式，是指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中，这种存储模式将地址的高低和数据位权有效地结合起来，高地址部分权值高，低地址部分权值低。

| 内存地址 | 小端模式存放内容 | 大端模式存放内容 |
| -------- | ---------------- | ---------------- |
| 0x4000   | 0x78             | 0x12             |
| 0x4001   | 0x56             | 0x34             |
| 0x4002   | 0x34             | 0x56             |
| 0x4003   | 0x12             | 0x78             |